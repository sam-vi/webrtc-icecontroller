<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>IceController Extensions for WebRTC</title>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
  <script src="respec-config.js" class="remove"></script>
</head>

<body>

  <section id="abstract">
    <p>
      This document defines a set of ECMAScript APIs in WebIDL to allow creation of an {{RTCIceController}} object to
      manage the ICE connection used by an {{RTCPeerConnection}}.
    </p>
  </section>

  <section id="sotd"></section>

  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>
      This specification extends the WebRTC specification [[WEBRTC]] to allow construction of an {{RTCIceController}}
      object to manage the ICE connection used by an {{RTCPeerConnection}}.
    </p>
  </section>

  <section id="conformance">
    <p>
      This specification defines conformance criteria that apply to a single product: the <dfn>user agent</dfn> that
      implements the interfaces that it contains.
    </p>
    <p>
      Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the
      end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to
      follow, and not intended to be performant.)
    </p>
    <p>
      Implementations that use ECMAScript to implement the APIs defined in this specification MUST implement them in a
      manner consistent with the ECMAScript Bindings defined in the Web IDL specification [[WEBIDL]], as this
      specification uses that specification and terminology.
    </p>
  </section>

  <section>
    <h2>Terminology</h2>
    <p>
      The {{EventHandler}} interface, representing a callback used for event handlers, is defined in [[!HTML]].
    </p>
    <p>
      The concepts [= queue a task =] and [= networking task source =] are defined in [[!HTML]].
    </p>
    <p>
      The concept [= fire an event =] is defined in [[!DOM]].
    </p>
    <p>
      The terms [= event =], [= event handlers =] and [= event handler event types =] are defined in [[!HTML]].
    </p>
    <p>
      The term <dfn>generation</dfn> is defined in [[RFC8838]] Section 2.
    </p>
    <p>
      When referring to exceptions, the terms [= exception/throw =] and [= exception/created =] are defined in
      [[!WEBIDL]].
    </p>
    <p>
      The term "throw" is used as specified in [[!INFRA]]: it terminates the current processing steps.
    </p>
    <p>
      The terms <dfn data-lt="reject|rejection|rejecting">rejected</dfn> and <dfn
        data-lt="resolve|resolves">resolved</dfn> used in the context of Promises are defined in [[!ECMASCRIPT-6.0]].
    </p>
    <p>
      {{DOMHighResTimeStamp}}, {{Performance.timeOrigin}}, and {{Performance.now()}} are defined in [[!HIGHRES-TIME]].
    </p>
    <p>
      A <dfn>timestamp</dfn> is expressed with {{DOMHighResTimeStamp}}, and is defined as
      {{Performance}}.{{Performance/timeOrigin}} + {{Performance}}.{{Performance/now()}} at the time at which a past
      event occurred or a future event will occur.
    </p>
  </section>


  <section id="rtcicecontroller">
    <h2><dfn class="export">RTCIceController</dfn> Interface</h2>
    <p>
      The {{RTCIceController}} interface allows an application to observe and affect certain actions that an <dfn>ICE
        agent</dfn> [[RFC5245]] undertakes, such as performing connectivity checks, nominating a candidate pair, and
      pruning candidate pairs when unviable or no longer necessary. It also allows the application to request the [= ICE
      agent =] to perform these actions for candidate pairs selected by the application.
    </p>
    <section id="rtcicecontroller-interface-definition">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
[Exposed=Window]
interface RTCIceController : EventTarget {
  constructor();

  readonly attribute RTCIceRole role;
  RTCIceCandidatePair? getSelectedCandidatePair();

  attribute EventHandler oncandidatepairadded;
  attribute EventHandler oncandidatepairupdated;
  attribute EventHandler oncandidatepairswitched;
  attribute EventHandler oncandidatepairdestroyed;

  attribute EventHandler onicepingproposed;
  attribute EventHandler oniceswitchproposed;
  attribute EventHandler onicepruneproposed;

  Promise&lt;undefined&gt; sendIcePing(RTCIceCandidatePair candidatePair);
  Promise&lt;undefined&gt; switchToCandidatePair(RTCIceCandidatePair candidatePair);
  Promise&lt;undefined&gt; pruneCandidatePairs(sequence&lt;RTCIceCandidatePair&gt; candidatePairs);
};</pre>
      </div>
    </section>
    <section>
      <h2>Constructor</h2>
      <dl data-link-for="RTCIceController" data-dfn-for="RTCIceController" class="constructors">
        <dt><dfn>constructor()</dfn></dt>
        <dd>
          <p>
            When the constructor is invoked, the [= user agent =] MUST run the following steps:
          </p>
          <ol class="algorithm">
            <li>
              Let |controller:RTCIceController| be a newly created {{RTCIceController}} object.
            </li>
            <li>
              Let |controller| have an <dfn data-dfn-for="RTCIceController">[[\IceRole]]</dfn> internal slot,
              initialized to {{RTCIceRole/"unknown"}}.
            </li>
            <li>
              Let |controller| have a <dfn data-dfn-for="RTCIceController">[[\SelectedCandidatePair]]</dfn>
              internal slot, initialized to <code>null</code>.
            </li>
            <li>
              Let |controller| have a <dfn data-dfn-for="RTCIceController">[[\PeerConnection]]</dfn> internal
              slot, initialized to <code>null</code>.
            </li>
            <li>
              Return |controller|.
            </li>
          </ol>
          <div>
            <em>No parameters.</em>
          </div>
        </dd>
      </dl>
    </section>
    <section>
      <h2>Attributes</h2>
      <dl data-link-for="RTCIceController" data-dfn-for="RTCIceController" class="attributes">
        <dt>
          <dfn>role</dfn> of type <span class="idlAttrType">{{RTCIceRole}}</span>, readonly
        </dt>
        <dd>
          <p>
            The {{role}} attribute MUST, on getting, return the value of the {{RTCIceController/[[IceRole]]}} internal
            slot.
          </p>
        </dd>
        <dt>
          <dfn>oncandidatepairadded</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            This event handler, of event handler event type {{candidatepairadded}}, MUST be fired any time the [= ICE
            agent =] has found a candidate pair.
          </p>
        </dd>
        <dt>
          <dfn>oncandidatepairupdated</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            This event handler, of event handler event type {{candidatepairupdated}}, MUST be fired any time the [= ICE
            agent =] completes a connectivity check on a candidate pair, and when a candidate pair undergoes a state
            change. This may have been a consequence of the application invoking {{RTCIceController/sendIcePing()}}.
          <p>
            The [= user agent =] MAY choose to batch together these events to reduce the volume and increase the
            efficiency of the updates.
          </p>
        </dd>
        <dt>
          <dfn>oncandidatepairswitched</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            This event handler, of event handler event type {{candidatepairswitched}}, MUST be fired when the [=ICE
            agent =] switched the transport to a different candidate pair. The switch may have been a consequence of the
            application invoking {{RTCIceController/switchToCandidatePair()}}.
          </p>
        </dd>
        <dt>
          <dfn>oncandidatepairdestroyed</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            This event handler, of event handler event type {{candidatepairdestroyed}}, MUST be fired any time the
            [= ICE agent =] destroys a candidate pair. This may have been a consequence of the application invoking
            {{RTCIceController/pruneCandidatePairs()}}.
          </p>
        </dd>
        <dt>
          <dfn>onicepingproposed</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            This event handler, of event handler event type {{icepingproposed}}, MUST be fired when the [=ICE agent =]
            has selected a candidate pair to ping for a connectivity check, but before the ping has actually been sent.
          </p>
          <p>
            This event handler MUST not be fired when the application has requested a connectivity check by invoking
            {{RTCIceController/sendIcePing()}}.
          </p>
        </dd>
        <dt>
          <dfn>oniceswitchproposed</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            This event handler, of event handler event type {{iceswitchproposed}}, MUST be fired when the [=ICE agent
            =] has selected a candidate pair to switch the transport to, but before the switch has actually occurred.
          </p>
          <p>
            This event handler MUST not be fired when the application has requested a candidate pair switch by invoking
            {{RTCIceController/switchToCandidatePair()}}.
          </p>
        </dd>
        <dt>
          <dfn>onicepruneproposed</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            This event handler, of event handler event type {{icepruneproposed}}, MUST be fired when the [=ICE agent =]
            has selected one or more candidate pairs to prune, but before the pruning has actually occurred.
          </p>
          <p>
            This event handler MUST not be fired when the application has requested to prune candidate pairs by invoking
            {{RTCIceController/pruneCandidatePairs()}}.
          </p>
        </dd>
      </dl>
    </section>
    <section>
      <h2>Methods</h2>
      <dl data-link-for="RTCIceController" data-dfn-for="RTCIceController" class="methods">
        <dt>
          <dfn>getSelectedCandidatePair</dfn>
        </dt>
        <dd>
          <p>
            The {{getSelectedCandidatePair}} method returns the candidate pair currently selected for the ICE
            transport. This method MUST return the value of the {{RTCIceController/[[SelectedCandidatePair]]}} slot.
            {{getSelectedCandidatePair}} returns <code>null</code> before at least one {{candidatepairswitched}} event
            is fired.
          </p>
        </dd>
        <dt>
          <dfn>sendIcePing</dfn>
        </dt>
        <dd>
          <p>
            The {{sendIcePing}} method attempts to send an ICE connectivity check on the provided candidate pair. When
            the {{sendIcePing}} method is invoked, the [= user agent =] MUST run the following steps:
          </p>
          <ol class=algorithm>
            <li>
              <p>
                Let |candidatePair:RTCIceCandidatePair| be the method's first argument.
              </p>
            </li>
            <li>
              <p>
                Let |controller:RTCIceController| be the {{RTCIceController}} object on which {{sendIcePing}} is
                invoked.
              </p>
            </li>
            <li>
              <p>
                Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object stored in
                |controller|.{{RTCIceController/[[PeerConnection]]}}.
              </p>
            </li>
            <li>
              <p>
                Let |p:Promise| be a new promise.
              </p>
            </li>
            <li>
              <p>
                Run the following steps in parallel:
              </p>
              <ol>
                <li>
                  <p>
                    Run the steps described by the [= validate() algorithm =] to which |connection|, a new sequence
                    containing |candidatePair|, and |p| are supplied as arguments.
                  </p>
                </li>
                <li>
                  <p>
                    If either the local or remote candidate pair identified by |candidatePair| is [=
                    administratively prohibited =], [= resolve =] |p| with <code>undefined</code>.
                  </p>
                  <div class="note">
                    <p>
                      A candidate is <dfn id="administratively-prohibited">administratively prohibited</dfn> if the [=
                      user
                      agent =] has decided not to allow connection attempts to this address, as described further in
                      {{RTCPeerConnection/addIceCandidate()}}.
                    </p>
                  </div>
                </li>
                <li>
                  <p>
                    If the current {{RTCIceCandidatePairReport/state}} of the candidate pair
                    {{RTCStatsIceCandidatePairState}} is {{RTCStatsIceCandidatePairState/"failed"}}, [= reject =]
                    |p| with a newly [= exception/created =] {{InvalidStateError}}.
                  </p>
                </li>
                <li>
                  <p>
                    If <code>X</code> connectivity checks have been sent in the previous <code>Y</code> duration of
                    time,
                    reject |p| with a newly [= exception/created =] {{QuotaExceededError}}.
                  </p>
                  <div class="note">
                    <p>
                      The exact nature of this rate-limiting check is TBD.
                    </p>
                  </div>
                </li>
                <li>
                  <p>
                    Instruct the [= ICE agent=] to construct and send a STUN check from the local candidate to the
                    remote
                    candidate.
                  </p>
                </li>
                <li>
                  <p>
                    [= Resolve =] |p| with <code>undefined</code>.
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <p>
                Return |p|.
              </p>
            </li>
          </ol>
        </dd>
        <dt>
          <dfn>switchToCandidatePair</dfn>
        </dt>
        <dd>
          <p>
            The {{switchToCandidatePair}} method attempts to switch the transport to the provided candidate pair. When
            the {{switchToCandidatePair}} method is invoked, the [= user agent =] MUST run the following steps:
          </p>
          <ol class=algorithm>
            <li>
              <p>
                Let |candidatePair:RTCIceCandidatePair| be the method's first argument.
              </p>
            </li>
            <li>
              <p>
                Let |controller:RTCIceController| be the {{RTCIceController}} object on which {{sendIcePing}} is
                invoked.
              </p>
            </li>
            <li>
              <p>
                Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object stored in
                |controller|.{{RTCIceController/[[PeerConnection]]}}.
              </p>
            </li>
            <li>
              <p>
                Let |p:Promise| be a new promise.
              </p>
            </li>
            <li>
              <p>
                Run the following steps in parallel:
              </p>
              <ol>
                <li>
                  <p>
                    Run the steps described by the [= validate() algorithm =] to which |connection|, a new sequence
                    containing |candidatePair|, and |p| are supplied as arguments.
                  </p>
                </li>
                <li>
                  <p>
                    If the current {{RTCIceCandidatePairReport/state}} of the candidate pair
                    {{RTCStatsIceCandidatePairState}} is not {{RTCStatsIceCandidatePairState/"succeeded"}}, reject
                    |p| with a newly [= exception/created =] {{InvalidStateError}}.
                  </p>
                  <div class="note">
                    <p>
                      Attempting to switch to a candidate pair with either a local or remote candidate that is [=
                      administratively prohibited =] will also lead to an abort at this stage, because connectivity
                      checks
                      are prohibited on such a candidate pair, so it will never transition to the
                      {{RTCStatsIceCandidatePairState/"succeeded"}} state.
                    </p>
                  </div>
                </li>
                <li>
                  <p>
                    Instruct the [= ICE agent =] to change the selected candidate pair to |candidatePair|.
                  </p>
                </li>
                <li>
                  <p>
                    [= Resolve =] |p| with undefined.
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <p>
                Return |p|.
              </p>
            </li>
          </ol>
        </dd>
        <dt>
          <dfn>pruneCandidatePairs</dfn>
        </dt>
        <dd>
          <p>
            The {{pruneCandidatePairs}} method attempts to prune the provided candidate pairs. When the
            {{pruneCandidatePairs}} method is invoked, the [= user agent =] MUST run the following steps:
          </p>
          <ol class=algorithm>
            <li>
              <p>
                Let |candidatePairs:sequence&lt;RTCIceCandidatePair&gt;| be the method's first argument.
              </p>
            </li>
            <li>
              <p>
                Let |controller:RTCIceController| be the {{RTCIceController}} object on which {{sendIcePing}} is
                invoked.
              </p>
            </li>
            <li>
              <p>
                Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object stored in
                |controller|.{{RTCIceController/[[PeerConnection]]}}.
              </p>
            </li>
            <li>
              <p>
                Let |p:Promise| be a new promise.
              </p>
            </li>
            <li>
              <p>
                Run the following steps in parallel:
              </p>
              <ol>
                <li>
                  <p>
                    Run the steps described by the [= validate() algorithm =] to which |connection|,
                    |candidatePairs|, and |p| are supplied as arguments.
                  </p>
                </li>
                <li>
                  <p>
                    Instruct the [= ICE agent =] to prune the candidate pairs in |candidatePairs|.
                  </p>
                </li>
                <li>
                  <p>
                    [= Resolve =] |p| with undefined.
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <p>
                Return |p|.
              </p>
            </li>
          </ol>
        </dd>
      </dl>
      <div>
        <p>
          The [= user agent =] MUST validate that the application is allowed to perform a requested operation. When this
          validation is requested, the [= user agent =] MUST <dfn id="rtcicecontroller-validate"
            data-lt="validate() algorithm">run the following steps</dfn>:
        </p>
        <ol class="algorithm">
          <li>
            <p>
              Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object,
              |candidatePairs:sequence&lt;RTCIceCandidatePair&gt;| be the sequence of candidate pairs, and |p:Promise|
              be the Promise supplied to the algorithm.
            </p>
          </li>
          <li>
            <p>
              If |connection| is <code>null</code>, [= reject =] |p| with a newly [= exception/created
              =] {{InvalidStateError}} and abort these steps.
            </p>
          </li>
          <li>
            <p>
              If |connection|.{{RTCPeerConnection/[[IsClosed]]}} is <code>true</code>, [= reject =]
              |p| with a newly [= exception/created =] {{InvalidStateError}}.
            </p>
          </li>
          <!-- TODO if possible to have no transport, add a check that rejects with invalid state. -->
          <li>
            <p>
              Let |transport:RTCIceTransport| be the sole {{RTCIceTransport}} object in use by |connection|.
            </p>
            <div class="note">
              <p>
                The presence of one and only one {{RTCIceTransport}} object is ensured by limiting the use of
                {{RTCIceController}} to cases where {{RTCBundlePolicy}} is set to {{RTCBundlePolicy/"max-bundle"}}.
              </p>
            </div>
          </li>
          <li>
            <p>
              If |transport|.{{RTCIceTransport/[[IceTransportState]]}} is either of
              {{RTCIceTransportState/"new"}}, {{RTCIceTransportState/"failed"}} or {{RTCIceTransportState/"closed"}},
              [= reject =] |p| with a newly [= exception/created =] {{InvalidStateError}}.
            </p>
          </li>
          <li>
            <p>
              If |candidatePair| does not identify a valid candidate pair sent in
              {{RTCIceController/oncandidatepairadded}}, [= reject =] |p| with a newly [= exception/created =]
              {{NotFoundError}}.
            </p>
            <div class="note">
              <p>
                A valid candidate pair will be composed of a local candidate gathered by |transport|, and a
                remote candidate received by |transport| via {{RTCPeerConnection/addIceCandidate()}} or a
                peer reflexive candidate.
              </p>
            </div>
          </li>
        </ol>
      </div>
    </section>
  </section>


  <section id="informational-events">
    <h2>Informational events</h2>
    <p>
      These events convey information about some action that has already taken place, and allow the application to have
      an up-to-date view of the relevant internal state of the [= ICE agent =].
    </p>

    <section id="rtcicecandidatepairevent">
      <h3><dfn>RTCIceCandidatePairEvent</dfn></h3>
      <p>
        The {{RTCIceController/candidatepairadded}} event uses the {{RTCIceCandidatePairEvent}} interface.
      </p>
      <div>
        <pre class="idl">
[Exposed=Window]
interface RTCIceCandidatePairEvent : Event {
  constructor(DOMString type, RTCIceCandidatePairEventInit eventInitDict);
  readonly attribute RTCIceCandidatePair candidatePair;
};</pre>
        <section>
          <h4>Constructors</h4>
          <dl data-link-for="RTCIceCandidatePairEvent" data-dfn-for="RTCIceCandidatePairEvent" class="constructors">
            <dt><dfn>RTCIceCandidatePairEvent.constructor()</dfn></dt>
            <dd></dd>
          </dl>
        </section>
        <section>
          <h4>Attributes</h4>
          <dl data-link-for="RTCIceCandidatePairEvent" data-dfn-for="RTCIceCandidatePairEvent" class="attributes">
            <dt>
              <dfn>candidatePair</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePair}}</span>, readonly
            </dt>
            <dd>
              <p>
                The {{candidatePair}} attribute is the {{RTCIceCandidatePair}} object with the new ICE candidate pair
                that was gathered by the [= ICE agent =].
              </p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
dictionary RTCIceCandidatePairEventInit : EventInit {
  required RTCIceCandidatePair candidatePair;
};</pre>
        <section id="rtcicecandidatepaireventinit">
          <h4>Dictionary <dfn>RTCIceCandidatePairEventInit</dfn> Members</h4>
          <dl data-link-for="RTCIceCandidatePairEventInit" data-dfn-for="RTCIceCandidatePairEventInit"
            class="dictionary-members">
            <dt>
              <dfn>candidatePair</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePair}}</span>, required
            </dt>
            <dd>
              <p>
                See the {{RTCIceCandidatePairEvent/candidatePair}} attribute of the {{RTCIceCandidatePairEvent}}
                interface.
              </p>
            </dd>
          </dl>
        </section>
      </div>
    </section>

    <section id="rtcicecandidatepairupdateevent">
      <h3><dfn>RTCIceCandidatePairUpdateEvent</dfn></h3>
      <p>
        The {{RTCIceController/candidatepairupdated}} event uses the {{RTCIceCandidatePairUpdateEvent}} interface.
      </p>
      <div>
        <pre class="idl">
[Exposed=Window]
interface RTCIceCandidatePairUpdateEvent : Event {
  constructor(DOMString type, RTCIceCandidatePairUpdateEventInit eventInitDict);
  readonly attribute RTCIceCandidatePair candidatePair;
  readonly attribute RTCIceCandidatePairReport report;
};</pre>
        <section>
          <h4>Constructors</h4>
          <dl data-link-for="RTCIceCandidatePairUpdateEvent" data-dfn-for="RTCIceCandidatePairUpdateEvent"
            class="constructors">
            <dt><dfn>RTCIceCandidatePairUpdateEvent.constructor()</dfn></dt>
            <dd></dd>
          </dl>
        </section>
        <section>
          <h4>Attributes</h4>
          <dl data-link-for="RTCIceCandidatePairUpdateEvent" data-dfn-for="RTCIceCandidatePairUpdateEvent"
            class="attributes">
            <dt>
              <dfn>candidatePair</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePair}}</span>, readonly
            </dt>
            <dd>
              <p>
                The {{candidatePair}} attribute is the {{RTCIceCandidatePair}} object that represents the candidate
                pair for which updated information is available.
              </p>
            </dd>
            <dt>
              <dfn>report</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePairReport}}</span>, readonly
            </dt>
            <dd>
              <p>
                The {{report}} attribute is the {{RTCIceCandidatePairReport}} object containing the information that
                the [= ICE agent =] has gathered about a candidate pair through ICE connectivity checks.
              </p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
dictionary RTCIceCandidatePairUpdateEventInit : EventInit {
  required RTCIceCandidatePair candidatePair;
  required RTCIceCandidatePairReport report;
};</pre>
        <section id="rtcicecandidatepairupdateeventinit">
          <h4>Dictionary <dfn>RTCIceCandidatePairUpdateEventInit</dfn> Members</h4>
          <dl data-link-for="RTCIceCandidatePairUpdateEventInit" data-dfn-for="RTCIceCandidatePairUpdateEventInit"
            class="dictionary-members">
            <dt>
              <dfn>candidatePair</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePair}}</span>, required
            </dt>
            <dd>
              <p>
                See the {{RTCIceCandidatePairUpdateEvent/candidatePair}} attribute of the
                {{RTCIceCandidatePairUpdateEvent}} interface.
              </p>
            </dd>
            <dt>
              <dfn>report</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePairReport}}</span>, required
            </dt>
            <dd>
              <p>
                See the {{RTCIceCandidatePairUpdateEvent/report}} attribute of the {{RTCIceCandidatePairUpdateEvent}}
                interface.
              </p>
            </dd>
          </dl>
        </section>
      </div>
      <section id="rtcicecandidatepairreport">
        <h4><dfn>RTCIceCandidatePairReport</dfn> Interface</h4>
        <div>
          <pre class="idl">
[Exposed=Window]
interface RTCIceCandidatePairReport {
  constructor(RTCIceCandidatePairReportInit reportInitDict);
  readonly attribute boolean connected;
  readonly attribute RTCStatsIceCandidatePairState state;
  readonly attribute RTCIceCandidatePairWriteState writeState;
  readonly attribute DOMHighResTimeStamp? lastPingSentTimestamp;
  readonly attribute DOMHighResTimeStamp? lastPingResponseReceivedTimestamp;
  readonly attribute DOMHighResTimeStamp? lastPingReceivedTimestamp;
  readonly attribute DOMHighResTimeStamp? lastPacketReceivedTimestamp;
  readonly attribute unsigned long long pingsSent;
  sequence&lt;RTCRoundTripTimeSample&gt; getRoundTripTimeSamples();
};</pre>
          <section>
            <h5>Constructors</h5>
            <dl data-link-for="RTCIceCandidatePairReport" data-dfn-for="RTCIceCandidatePairReport" class="constructors">
              <dt><dfn>RTCIceCandidatePairReport.constructor()</dfn></dt>
              <dd></dd>
            </dl>
          </section>
          <section>
            <h5>Attributes</h5>
            <dl data-link-for="RTCIceCandidatePairReport" data-dfn-for="RTCIceCandidatePairReport" class="attributes">
              <dt>
                <dfn>connected</dfn> of type <span class="idlAttrType">boolean</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{connected}} attribute represents whether the ICE candidate pair is in connected state.
                </p>
              </dd>
              <dt>
                <dfn>state</dfn> of type <span class="idlAttrType">RTCStatsIceCandidatePairState</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{state}} attribute represents the state of a candidate pair in an ICE check list defined in
                  Section 6.1.2.6 of [[RFC8445]].
                </p>
              </dd>
              <dt>
                <dfn>writeState</dfn> of type <span class="idlAttrType">RTCIceCandidatePairWriteState</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{writeState}} attribute indicates the write state of the candidate pair.
                </p>
              </dd>
              <dt>
                <dfn>lastPingSentTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{lastPingSentTimestamp}} attribute, if present, represents the [= timestamp =] at which the last
                  ping was sent for an ICE connectivity check on this candidate pair.
                </p>
              </dd>
              <dt>
                <dfn>lastPingResponseReceivedTimestamp</dfn> of type <span
                  class="idlAttrType">DOMHighResTimeStamp</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{lastPingResponseReceivedTimestamp}} attribute, if present, represents the [= timestamp =] at
                  which the last response was received to a ping for an ICE connectivity check on this candidate pair.
                </p>
              </dd>
              <dt>
                <dfn>lastPingReceivedTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>,
                readonly
              </dt>
              <dd>
                <p>
                  The {{lastPingReceivedTimestamp}} attribute, if present, represents the [= timestamp =] at which the
                  last ping was received from the peer for an ICE connectivity check on this candidate pair.
                </p>
              </dd>
              <dt>
                <dfn>lastPacketReceivedTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>,
                readonly
              </dt>
              <dd>
                <p>
                  The {{lastPacketReceivedTimestamp}} attribute, if present, represents the [= timestamp =] at which the
                  last packet was received on this candidate pair, excluding STUN packets.
                </p>
              </dd>
              <dt>
                <dfn>pingsSent</dfn> of type <span class="idlAttrType">unsigned long long</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{pingsSent}} attribute represents the total number of pings sent for ICE connectivity check on
                  this candidate pair.
                </p>
              </dd>
            </dl>
          </section>
          <section>
            <h5>Methods</h5>
            <dl data-link-for="RTCIceCandidatePairReport" data-dfn-for="RTCIceCandidatePairReport" class="methods">
              <dt>
                <dfn>getRoundTripTimeSamples</dfn>
              </dt>
              <dd>
                <p>
                  The {{getRoundTripTimeSamples}} method returns all the round trip time samples gathered for this
                  candidate pair.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">
dictionary RTCIceCandidatePairReportInit {
  required boolean connected;
  required RTCStatsIceCandidatePairState state;
  required RTCIceCandidatePairWriteState writeState;
  DOMHighResTimeStamp lastPingSentTimestamp;
  DOMHighResTimeStamp lastPingResponseReceivedTimestamp;
  DOMHighResTimeStamp lastPingReceivedTimestamp;
  DOMHighResTimeStamp lastPacketReceivedTimestamp;
  required unsigned long long pingsSent;
  sequence&lt;RTCRoundTripTimeSample&gt; roundTripTimeSamples;
};</pre>
          <section id="rtcicecandidatepairreportinit">
            <h6>Dictionary <dfn>RTCIceCandidatePairReportInit</dfn> Members</h6>
            <dl data-link-for="RTCIceCandidatePairReportInit" data-dfn-for="RTCIceCandidatePairReportInit"
              class="dictionary-members">
              <dt>
                <dfn>connected</dfn> of type <span class="idlAttrType">boolean</span>, required
              </dt>
              <dd>
                <p>
                  The {{connected}} member represents whether the ICE candidate pair is in connected state.
                </p>
              </dd>
              <dt>
                <dfn>state</dfn> of type <span class="idlAttrType">RTCStatsIceCandidatePairState</span>, required
              </dt>
              <dd>
                <p>
                  The {{state}} member represents the state of a candidate pair in an ICE check list defined in
                  Section 6.1.2.6 of [[RFC8445]].
                </p>
              </dd>
              <dt>
                <dfn>writeState</dfn> of type <span class="idlAttrType">RTCIceCandidatePairWriteState</span>, required
              </dt>
              <dd>
                <p>
                  The {{writeState}} member indicates the write state of the candidate pair.
                </p>
              </dd>
              <dt>
                <dfn>lastPingSentTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>
              </dt>
              <dd>
                <p>
                  The {{lastPingSentTimestamp}} member, if present, represents the [= timestamp =] at which the last
                  ping was sent for an ICE connectivity check on this candidate pair.
                </p>
              </dd>
              <dt>
                <dfn>lastPingResponseReceivedTimestamp</dfn> of type <span
                  class="idlAttrType">DOMHighResTimeStamp</span>
              </dt>
              <dd>
                <p>
                  The {{lastPingResponseReceivedTimestamp}} member, if present, represents the [= timestamp =] at which
                  the last response was received to a ping for an ICE connectivity check on this candidate pair.
                </p>
              </dd>
              <dt>
                <dfn>lastPingReceivedTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>
              </dt>
              <dd>
                <p>
                  The {{lastPingReceivedTimestamp}} member, if present, represents the [= timestamp =] at which the last
                  ping was received from the peer for an ICE connectivity check on this candidate pair.
                </p>
              </dd>
              <dt>
                <dfn>lastPacketReceivedTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>
              </dt>
              <dd>
                <p>
                  The {{lastPacketReceivedTimestamp}} member, if present, represents the [= timestamp =] at which the
                  last packet was received on this candidate pair, excluding STUN packets.
                </p>
              </dd>
              <dt>
                <dfn>pingsSent</dfn> of type <span class="idlAttrType">unsigned long long</span>, required
              </dt>
              <dd>
                <p>
                  The {{pingsSent}} member represents the total number of pings sent for ICE connectivity check on
                  this candidate pair.
                </p>
              </dd>
              <dt>
                <dfn>roundTripTimeSamples</dfn> of type <span
                  class="idlAttrType">sequence&lt;{{RTCRoundTripTimeSample}}&gt;</span>
              </dt>
              <dd>
                <p>
                  The {{roundTripTimeSamples}} member, if present, represents all the round trip time samples gathered
                  for this candidate pair.
                </p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section id="rtcroundtriptimesample">
        <h4><dfn>RTCRoundTripTimeSample</dfn> Dictionary</h4>
        <div>
          <pre class="idl">
dictionary RTCRoundTripTimeSample {
  required DOMHighResTimeStamp timestamp;
  required double value;
};</pre>
          <section>
            <h5>Dictionary {{RTCRoundTripTimeSample}} Members</h5>
            <dl data-link-for="RTCRoundTripTimeSample" data-dfn-for="RTCRoundTripTimeSample" class="dictionary-members">
              <dt>
                <dfn>timestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>, required
              </dt>
              <dd>
                <p>
                  The {{RTCRoundTripTimeSample/timestamp}} member represents the time at which this round trip time
                  sample was measured.
                </p>
              </dd>
              <dt>
                <dfn>value</dfn> of type <span class="idlAttrType">double</span>, required
              </dt>
              <dd>
                <p>
                  The {{value}} member indicates the measured round trip time in this sample.
                </p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section id="rtcicecandidatepairwritestate">
        <h4><dfn>RTCIceCandidatePairWriteState</dfn> Enum</h4>
        <p>
          The {{RTCIceCandidatePairWriteState}} represents the write state of the ICE candidate pair as determined by
          the [= ICE agent =]. The exact criteria for determining the write state, i.e. the number of failures or the
          timeout period, is left up to the browser
          implementation.
        </p>
        <div>
          <pre class="idl">
enum RTCIceCandidatePairWriteState {
  "init",
  "writeable",
  "unreliable",
  "timeout"
};</pre>
          <table data-link-for="RTCIceCandidatePairWriteState" data-dfn-for="RTCIceCandidatePairWriteState"
            class="simple">
            <caption>{{RTCIceCandidatePairWriteState}} Enumeration description</caption>
            <thead>
              <tr>
                <th>Enum value</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <dfn>init</dfn>
                </td>
                <td>
                  Responses have not yet been received to connectivity check on this candidate pair, but the timeout has
                  not elapsed.
                </td>
              </tr>
              <tr>
                <td>
                  <dfn>writeable</dfn>
                </td>
                <td>
                  Responses have been received recently to connectivity checks, and the candidate pair is considered
                  writeable.
                </td>
              </tr>
              <tr>
                <td>
                  <dfn>unreliable</dfn>
                </td>
                <td>
                  Some connectivity check have failed recently for this candidate pair, but it may still be writeable.
                </td>
              </tr>
              <tr>
                <td>
                  <dfn>timeout</dfn>
                </td>
                <td>
                  A large number of connectivity checks have failed and the candidate pair is not considered writeable
                  any longer.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </section>

  </section>


  <section id="proposal-events">
    <h2>Proposal events</h2>
    <p>
      These events represent some action that the [= ICE agent =] is proposing to take with regards to ICE connectivity
      checks, changing the candidate pair used for the transport, or maintainence of the candidate pairs. The
      application can affect the operation of the [= ICE agent =] by rejecting any of the proposed actions, and
      initiating its own actions instead through {{RTCIceController}} methods.
    </p>

    <section id="rtcicepingproposalevent">
      <h3><dfn>RTCIcePingProposalEvent</dfn></h3>
      <p>
        The {{RTCIceController/icepingproposed}} event uses the {{RTCIcePingProposalEvent}} interface. The
        {{RTCIceController/icepingproposed}} event is fired when the [= ICE agent =] has selected a candidate pair to
        ping for connectivity check, but the ping has not yet been sent.
      </p>
      <p>
        The {{Event/cancelable}} attribute of the event is initialized to <code>true</code>. If the application sets
        the canceled flag of the event by invoking {{Event/preventDefault()}} with the event, the [= user agent =] MUST
        not proceed with sending the proposed connectivity check. The [= user agent =] MAY continue to propose further
        connectivity checks in the future for the same or other candidate pairs.
      </p>
      <p>
        If the application does not invoke {{Event/preventDefault()}} with the event, the [= user agent =] SHOULD
        continue to send the proposed connectivity check, unless a change in circumstances has made the check infeasible
        or unnecessary.
      </p>
      <div>
        <pre class="idl">
[Exposed=Window]
interface RTCIcePingProposalEvent : Event {
  constructor(DOMString type, RTCIcePingProposalEventInit eventInitDict);
  readonly attribute RTCIceCandidatePair candidatePair;
  readonly attribute DOMHighResTimeStamp? lastPingSentTimestamp;
  readonly attribute DOMHighResTimeStamp? earliestNextPingTimestamp;
};</pre>
        <section>
          <h4>Constructors</h4>
          <dl data-link-for="RTCIcePingProposalEvent" data-dfn-for="RTCIcePingProposalEvent" class="constructors">
            <dt><dfn>RTCIcePingProposalEvent.constructor()</dfn></dt>
            <dd></dd>
          </dl>
        </section>
        <section>
          <h4>Attributes</h4>
          <dl data-link-for="RTCIcePingProposalEvent" data-dfn-for="RTCIcePingProposalEvent" class="attributes">
            <dt>
              <dfn>candidatePair</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePair}}</span>, readonly
            </dt>
            <dd>
              <p>
                The {{candidatePair}} attribute is the {{RTCIceCandidatePair}} object that represents the candidate
                pair that the [= ICE agent =] has selected to ping for a connectivity check.
              </p>
            </dd>
            <dt>
              <dfn>lastPingSentTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>, readonly,
              nullable
            </dt>
            <dd>
              <p>
                The {{lastPingSentTimestamp}} attribute represents the [= timestamp =] at which the last connectivity
                check ping was sent by the [= ICE agent =].
              </p>
            </dd>
            <dt>
              <dfn>earliestNextPingTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>,
              readonly, nullable
            </dt>
            <dd>
              <p>
                The {{earliestNextPingTimestamp}} attribute represents the earliest [= timestamp =] at which the [= ICE
                agent =] will select another candidate pair to ping for connectivity check.
              </p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
dictionary RTCIcePingProposalEventInit : EventInit {
  required RTCIceCandidatePair candidatePair;
  DOMHighResTimeStamp lastPingSentTimestamp;
  DOMHighResTimeStamp earliestNextPingTimestamp;
};</pre>
        <section id="rtcicepingproposaleventinit">
          <h4>Dictionary <dfn>RTCIcePingProposalEventInit</dfn> Members</h4>
          <dl data-link-for="RTCIcePingProposalEventInit" data-dfn-for="RTCIcePingProposalEventInit"
            class="dictionary-members">
            <dt>
              <dfn>candidatePair</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePair}}</span>, required
            </dt>
            <dd>
              <p>
                See the {{RTCIcePingProposalEvent/candidatePair}} attribute of the
                {{RTCIcePingProposalEvent}} interface.
              </p>
            </dd>
            <dt>
              <dfn>lastPingSentTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>
            </dt>
            <dd>
              <p>
                See the {{RTCIcePingProposalEvent/lastPingSentTimestamp}} attribute of the
                {{RTCIcePingProposalEvent}} interface.
              </p>
            </dd>
            <dt>
              <dfn>earliestNextPingTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>
            </dt>
            <dd>
              <p>
                See the {{RTCIcePingProposalEvent/earliestNextPingTimestamp}} attribute of the
                {{RTCIcePingProposalEvent}} interface.
              </p>
            </dd>
          </dl>
        </section>
      </div>
    </section>

    <section id="rtciceswitchproposalevent">
      <h3><dfn>RTCIceSwitchProposalEvent</dfn></h3>
      <p>
        The {{RTCIceController/iceswitchproposed}} event uses the {{RTCIceSwitchProposalEvent}} interface. The
        {{RTCIceController/iceswitchproposed}} event is fired when the [= ICE agent =] has selected a candidate pair to
        switch the transport to, but the switch has not yet occurred.
      </p>
      <p>
        The {{Event/cancelable}} attribute of the event is initialized to <code>false</code> if the
        {{RTCIceSwitchProposalEvent/reason}} for the event is one of {{RTCIceSwitchReason/"data-received"}},
        {{RTCIceSwitchReason/"nomination-on-controlled-side"}}, or
        {{RTCIceSwitchReason/"selected-connection-destroyed"}}, indicating that such a switch may not be prevented by
        the application. Otherwise, the {{Event/cancelable}} attribute is initialized to <code>true</code>.
      </p>
      <p>
        If the application sets the canceled flag of the event by invoking {{Event/preventDefault()}} with the event,
        the [= user agent =] MUST not proceed with the switch to the proposed candidate pair. The [= user agent =] MAY
        continue to propose further switches in the future to the same or other candidate pairs.
      </p>
      <p>
        If the application does not invoke {{Event/preventDefault()}} with the event, the [= user agent =] SHOULD
        continue to switch the transport to the proposed candidate pair, unless a change in circumstances has made the
        switch infeasible or unnecessary.
      </p>
      <div>
        <pre class="idl">
[Exposed=Window]
interface RTCIceSwitchProposalEvent : Event {
  constructor(DOMString type, RTCIceSwitchProposalEventInit eventInitDict);
  readonly attribute RTCIceCandidatePair candidatePair;
  readonly attribute RTCIceSwitchReason reason;
  readonly attribute RTCIceRecheck? recheck;
};</pre>
        <section>
          <h4>Constructors</h4>
          <dl data-link-for="RTCIceSwitchProposalEvent" data-dfn-for="RTCIceSwitchProposalEvent" class="constructors">
            <dt><dfn>RTCIceSwitchProposalEvent.constructor()</dfn></dt>
            <dd></dd>
          </dl>
        </section>
        <section>
          <h4>Attributes</h4>
          <dl data-link-for="RTCIceSwitchProposalEvent" data-dfn-for="RTCIceSwitchProposalEvent" class="attributes">
            <dt>
              <dfn>candidatePair</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePair}}</span>, readonly
            </dt>
            <dd>
              <p>
                The {{candidatePair}} attribute is the {{RTCIceCandidatePair}} object that represents the candidate
                pair that the [= ICE agent =] has selected to switch to using for the transport.
              </p>
            </dd>
            <dt>
              <dfn>reason</dfn> of type <span class="idlAttrType">{{RTCIceSwitchReason}}</span>, readonly
            </dt>
            <dd>
              <p>
                The {{reason}} attribute represents the reason that triggered the [= ICE agent =] to search for a
                different candidate pair to switch the transport to.
              </p>
            </dd>

            <dt>
              <dfn>recheck</dfn> of type <span class="idlAttrType">{{RTCIceRecheck}}</span>, readonly, nullable
            </dt>
            <dd>
              <p>
                The {{recheck}} attribute represent a future trigger for the [= ICE agent =] to search for a different
                candidate pair to switch the transport to.
              </p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
dictionary RTCIceSwitchProposalEventInit : EventInit {
  required RTCIceCandidatePair candidatePair;
  required RTCIceSwitchReason reason;
  RTCIceRecheck recheck;
};</pre>
        <section id="rtciceswitchproposaleventinit">
          <h4>Dictionary <dfn>RTCIceSwitchProposalEventInit</dfn> Members</h4>
          <dl data-link-for="RTCIceSwitchProposalEventInit" data-dfn-for="RTCIceSwitchProposalEventInit"
            class="dictionary-members">
            <dt>
              <dfn>candidatePair</dfn> of type <span class="idlAttrType">{{RTCIceCandidatePair}}</span>, required
            </dt>
            <dd>
              <p>
                See the {{RTCIceSwitchProposalEvent/candidatePair}} attribute of the
                {{RTCIceSwitchProposalEvent}} interface.
              </p>
            </dd>
            <dt>
              <dfn>reason</dfn> of type <span class="idlAttrType">{{RTCIceSwitchReason}}</span>, required
            </dt>
            <dd>
              <p>
                See the {{RTCIceSwitchProposalEvent/reason}} attribute of the
                {{RTCIceSwitchProposalEvent}} interface.
              </p>
            </dd>
            <dt>
              <dfn>recheck</dfn> of type <span class="idlAttrType">{{RTCIceRecheck}}</span>
            </dt>
            <dd>
              <p>
                See the {{RTCIceSwitchProposalEvent/recheck}} attribute of the
                {{RTCIceSwitchProposalEvent}} interface.
              </p>
            </dd>
          </dl>
        </section>
      </div>
      <section id="rtciceswitchreason">
        <h4><dfn>RTCIceSwitchReason</dfn> Enum</h4>
        <div>
          <pre class="idl">
enum RTCIceSwitchReason {
  "remote-candidate-generation-change",
  "network-preference-change",
  "new-connection-from-local-candidate",
  "new-connection-from-remote-candidate",
  "new-connection-from-unknown-remote-address",
  "nomination-on-controlled-side",
  "data-received",
  "connect-state-change",
  "selected-connection-destroyed",
  "scheduled-recheck"
};</pre>
          <table data-link-for="RTCIceSwitchReason" data-dfn-for="RTCIceSwitchReason" class="simple">
            <caption>{{RTCIceSwitchReason}} Enumeration description</caption>
            <thead>
              <tr>
                <th>Enum value</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <dfn>remote-candidate-generation-change</dfn>
                </td>
                <td>The {{generation}} of the remote ICE candidate possibly changed.</td>
              </tr>
              <tr>
                <td>
                  <dfn>network-preference-change</dfn>
                </td>
                <td>The preferred network type changed for the [= user agent =] .</td>
              </tr>
              <tr>
                <td>
                  <dfn>new-connection-from-local-candidate</dfn>
                </td>
                <td>A candidate pair was created from a new local ICE candidate.</td>
              </tr>
              <tr>
                <td>
                  <dfn>new-connection-from-remote-candidate</dfn>
                </td>
                <td>A candidate pair was created from a new remote ICE candidate.</td>
              </tr>
              <tr>
                <td>
                  <dfn>new-connection-from-unknown-remote-address</dfn>
                </td>
                <td>A new candidate pair was created from an unknown remote address.</td>
              </tr>
              <tr>
                <td>
                  <dfn>nomination-on-controlled-side</dfn>
                </td>
                <td>A nomination for a candidate pair was received on the ICE {{RTCIceRole/"controlled"}} peer.</td>
              </tr>
              <tr>
                <td>
                  <dfn>data-received</dfn>
                </td>
                <td>The [= user agent =] received data on a candidate pair.</td>
              </tr>
              <tr>
                <td>
                  <dfn>connect-state-change</dfn>
                </td>
                <td>A candidate pair underwent a state change.</td>
              </tr>
              <tr>
                <td>
                  <dfn>selected-connection-destroyed</dfn>
                </td>
                <td>The selected candidate pair was destroyed.</td>
              </tr>
              <tr>
                <td>
                  <dfn>scheduled-recheck</dfn>
                </td>
                <td>A periodic check for a different candidate pair was triggered.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section id="rtcicerecheck">
        <h4><dfn>RTCIceRecheck</dfn> Dictionary</h4>
        <div>
          <pre class="idl">
dictionary RTCIceRecheck {
  required RTCIceSwitchReason reason;
  required DOMHighResTimeStamp earliestRecheckTimestamp;
};</pre>
          <section>
            <h5>Dictionary {{RTCIceRecheck}} Members</h5>
            <dl data-link-for="RTCIceRecheck" data-dfn-for="RTCIceRecheck" class="dictionary-members">
              <dt>
                <dfn>reason</dfn> of type <span class="idlAttrType">RTCIceSwitchReason</span>, required
              </dt>
              <dd>
                <p>
                  The {{reason}} member represents the reason for the future trigger to search for a different
                  candidate pair for the transport.
                </p>
              </dd>
              <dt>
                <dfn>earliestRecheckTimestamp</dfn> of type <span class="idlAttrType">DOMHighResTimeStamp</span>,
                required
              </dt>
              <dd>
                <p>
                  The {{earliestRecheckTimestamp}} member indicates the earliest [= timestamp =] at which the future
                  check will be performed.
                </p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
    </section>

    <section id="rtcicepruneproposalevent">
      <h3><dfn>RTCIcePruneProposalEvent</dfn></h3>
      <p>
        The {{RTCIceController/icepruneproposed}} event uses the {{RTCIcePruneProposalEvent}} interface. The
        {{RTCIceController/icepruneproposed}} event is fired when the [= ICE agent =] has selected some candidate pairs
        to prune, but the pruning has not yet happened.
      </p>
      <p>
        The {{Event/cancelable}} attribute of the event is initialized to <code>true</code>. If the application sets the
        canceled flag of the event by invoking {{Event/preventDefault()}} with the event, the [= user agent =] MUST not
        proceed with pruning the proposed candidate pairs. The [= user agent =] MAY continue to propose pruning of the
        same or other candidate pairs in the future.
      </p>
      <p>
        If the application does not invoke {{Event/preventDefault()}} with the event, the [= user agent =] SHOULD
        continue with pruning the proposed candidate pairs, unless a change in circumstances has made the pruning
        infeasible or unnecessary.
      </p>
      <div>
        <pre class="idl">
[Exposed=Window]
interface RTCIcePruneProposalEvent : Event {
  constructor(DOMString type, RTCIcePruneProposalEventInit eventInitDict);
  sequence&lt;RTCIceCandidatePair&gt; getCandidatePairs();
};</pre>
        <section>
          <h4>Constructors</h4>
          <dl data-link-for="RTCIcePruneProposalEvent" data-dfn-for="RTCIcePruneProposalEvent" class="constructors">
            <dt><dfn>RTCIcePruneProposalEvent.constructor()</dfn></dt>
            <dd></dd>
          </dl>
        </section>
        <section>
          <h4>Methods</h4>
          <dl data-link-for="RTCIcePruneProposalEvent" data-dfn-for="RTCIcePruneProposalEvent" class="methods">
            <dt>
              <dfn>getCandidatePairs</dfn>
            </dt>
            <dd>
              <p>
                The {{getCandidatePairs}} method returns the candidate pairs selected by the [= ICE agent =] for pruning
                at this time.
              </p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
dictionary RTCIcePruneProposalEventInit : EventInit {
  required sequence&lt;RTCIceCandidatePair&gt; candidatePairs;
};</pre>
        <section id="rtcicepruneproposaleventinit">
          <h5>Dictionary <dfn>RTCIcePruneProposalEventInit</dfn> Members</h5>
          <dl data-link-for="RTCIcePruneProposalEventInit" data-dfn-for="RTCIcePruneProposalEventInit"
            class="dictionary-members">
            <dt>
              <dfn>candidatePairs</dfn> of type <span
                class="idlAttrType">sequence&lt;{{RTCIceCandidatePair}}&gt;</span>, required
            </dt>
            <dd>
              <p>
                The {{candidatePairs}} member represents the candidate pairs selected by the [= ICE agent =] for
                pruning at this time.
              </p>
            </dd>
          </dl>
        </section>
      </div>
    </section>

  </section>

  <section id="rtcpeerconnection">
    <h2>{{RTCPeerConnection}} Extensions</h2>
    <p>
      The {{RTCPeerConnection}} extension allows associating an {{RTCIceController}} with an {{RTCPeerConnection}}
      object at the time of its construction or through {{RTCPeerConnection/setConfiguration()}}. An application can
      test for support of this specification by checking for the presence of an {{RTCIceController}} prototype object.
    </p>

    <section id="rtcconfiguration">
      <h3>{{RTCConfiguration}} Extensions</h3>
      <p>
        The {{RTCConfiguration}} dictionary is extended with an {{RTCConfiguration/iceController}} member.
      </p>
      <div>
        <pre class="idl">
partial dictionary RTCConfiguration {
  RTCIceController iceController;
};</pre>
        <section>
          <h4>Dictionary {{RTCConfiguration}} Members</h4>
          <dl data-link-for="RTCConfiguration" data-dfn-for="RTCConfiguration" class="dictionary-members">
            <dt>
              <dfn>iceController</dfn> of type <span class="idlMemberType">{{RTCIceController}}</span>
            </dt>
            <dd>
              <p>
                The {{iceController}} member represents the {{RTCIceController}} object to associate with the
                {{RTCPeerConnection}}. Proposals from its [= ICE agent =] will result in events firing on
                {{iceController}} while it is associated with the {{RTCPeerConnection}}.
              </p>
            </dd>
          </dl>
        </section>
      </div>
    </section>

    <section>
      <h3>Operation</h3>
      <p>
        Certain additional steps need to be performed during the construction of an {{RTCPeerConnection}} and when
        {{RTCPeerConnection/setConfiguration()}} is invoked to establish its association with an {{RTCIceController}},
        if supplied. Both operations achieve this through an extension to [= Set the configuration =] operation.
      </p>
      <section>
        <h4>Constructor</h4>
        <p>
          When the <code>RTCPeerConnection.constructor()</code> is invoked, run the following additional steps:</p>
        <ol class=algorithm>
          <li>
            <p>
              Let |connection:RTCPeerConnection| be the newly created {{RTCPeerConnection}} object.
            </p>
          </li>
          <li>
            <p>
              Let |connection| have an <dfn data-dfn-for="RTCPeerConnection">[[\IceController]]</dfn> internal
              slot, initialized to <code>null</code>.
            </p>
          </li>
        </ol>
      </section>
      <section>
        <h4>Set the configuration</h4>
        <p>
          To <dfn data-lt="set the configuration" id="set-pc-configuration">set a configuration</dfn> with
          |configuration:RTCConfiguration|, run the following additional steps:
        </p>
        <ol class=algorithm>
          <li>
            <p>
              Let |connection:RTCPeerConnection| be the target {{RTCPeerConnection}} object.
            </p>
          </li>
          <li>
            <p>
              Let |oldConfig:RTCConfiguration| be |connection|.<code>[[\Configuration]]</code>.
            </p>
          </li>
          <li>
            <p>
              If |oldConfig| is not <code>null</code>, and if the value of
              |configuration|.{{RTCConfiguration/iceController}} differs from
              |oldConfig|.{{RTCConfiguration/iceController}}, [= exception/throw =] an {{InvalidModificationError}}.
            </p>
          </li>
          <li>
            <p>
              Otherwise, if |configuration|.{{RTCConfiguration/iceController}} is not <code>null</code>, run
              the following steps:
            </p>
            <ol>
              <li>
                <p>
                  If |configuration|.{{RTCConfiguration/iceController}}.{{RTCIceController/[[PeerConnection]]}}
                  is not null, [= exception/throw =] an {{InvalidModificationError}}.
                </p>
              </li>
              <li>
                <p>
                  If the value of |configuration|.{{RTCConfiguration/bundlePolicy}} is not
                  {{RTCBundlePolicy/"max-bundle"}}, [= exception/throw =] a {{NotSupportedError}}.
                </p>
                <div class="note">
                  <p>
                    The use of an {{RTCIceController}} is currently only supported when {{RTCBundlePolicy}} is set to
                    {{RTCBundlePolicy/"max-bundle"}}, and thus only one media track is negotiated and a single
                    {{RTCIceTransport}} is used.
                  </p>
                  <p>
                    A future extension to the specification is possible either by allowing to associate an
                    {{RTCIceController}} with each individual {{RTCIceTransport}} or by multiplexing of several
                    {{RTCIceTransport}} events and actions to a single {{RTCIceController}}.
                  </p>
                </div>
              </li>
              <li>
                <p>
                  If the value of |configuration|.{{RTCConfiguration/iceCandidatePoolSize}} is not
                  <code>0</code>, [= exception/throw =] a {{NotSupportedError}}.
                </p>
                <div class="note">
                  <p>
                    For simplicity, the use of an {{RTCIceController}} is currently only supported when the application
                    does not use a prefetched ICE pool as defined in [[RFC8829]] (section <a
                      href="https://datatracker.ietf.org/doc/html/rfc8829#section-3.5.4">3.5.4</a> and section
                    <a href="https://datatracker.ietf.org/doc/html/rfc8829#section-4.1.1">4.1.1</a>).
                  </p>
                </div>
              </li>
              <li>
                <p>
                  Store |configuration|.{{RTCConfiguration/iceController}} in the
                  {{RTCPeerConnection/[[IceController]]}} internal slot.
                </p>
              </li>
              <li>
                <p>
                  Store |connection| in {{RTCIceController/[[PeerConnection]]}} of
                  |configuration|.{{RTCConfiguration/iceController}}.
                </p>
              </li>
            </ol>
          </li>
        </ol>
      </section>
      <section>
        <h4>Set the session description</h4>
        <p>
          When either {{RTCPeerConnection/setLocalDescription()}} or {{RTCPeerConnection/setRemoteDescription()}} is
          invoked, and a session description is set as a result, run the following additional steps:
        </p>
        <ol class="algorithm">
          <li>
            <p>
              Let |connection:RTCPeerConnection| be the target {{RTCPeerConnection}} object.
            </p>
          </li>
          <li>
            <p>
              If |connection|.{{RTCPeerConnection/[[IceController]]}} is null, abort these steps.
            </p>
          </li>
          <li>
            <p>
              Let |controller:RTCIceController| be the {{RTCIceController}} object stored in
              |connection|.{{RTCPeerConnection/[[IceController]]}}.
            </p>
          </li>
          <li>
            <p>
              When setting the {{RTCIceTransport/[[IceRole]]}} of the relevant {{RTCIceTransport}} object according to
              the rules of [[RFC8445]], also set |controller|.{{RTCIceController/[[IceRole]]}} to the same
              value.
            </p>
          </li>
        </ol>
      </section>
    </section>

  </section>

  <section id="rtcicetransport">
    <h2>{{RTCIceTransport}} Extensions</h2>
    <p>
      The {{RTCIceTransport}} extensions allow accessing a small subset of the attributes of an {{RTCIceTransport}}
      object through an {{RTCIceController}} object to make it easy for an application to refer to this information.
    </p>
    <p>
      The {{RTCIceTransport}} extensions do not change the interface of {{RTCIceTransport}} or its associated types.
      Rather, they specify certain additional steps to be performed during the course of {{RTCIceTransport}} operations.
    </p>
    <p>
      When the [= ICE agent =] signals that the ICE role for an {{RTCIceTransport}} has changed due to an ICE binding
      request with a role collision per [[RFC8445]] section 7.3.1.1, the [= user agent =] will [= queue a task =] on the
      [= networking task source =] to set the value of {{RTCIceTransport/[[IceRole]]}} for the {{RTCIceTransport}} to
      the new value. The task will also set the value of {{RTCIceController/[[IceRole]]}} for the
      {{RTCPeerConnection/[[IceController]]}} of the {{RTCPeerConnection}} object associated with this [= ICE agent =]
      to the new value.
    </p>
    <p>
      When the [= ICE agent =] indicates that an {{RTCIceTransport}} has changed the selected candidate pair, run the
      following additional steps:
    </p>
    <ol class="algorithm">
      <li>
        <p>
          Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object associated with this [= ICE agent =].
        </p>
      </li>
      <li>
        <p>
          If |connection|.{{RTCPeerConnection/[[IceController]]}} is null, abort these steps.
        </p>
      </li>
      <li>
        <p>
          Let |controller:RTCIceController| be the {{RTCIceController}} object stored in
          |connection|.{{RTCPeerConnection/[[IceController]]}}.
        </p>
      </li>
      <li>
        <p>
          Let |newCandidatePair:RTCIceCandidatePair| be a newly created {{RTCIceCandidatePair}} representing the
          indicated pair if one is selected, and <code>null</code> otherwise.
        </p>
      </li>
      <li>
        <p>
          Set |controller|.{{RTCIceController/[[SelectedCandidatePair]]}} to |newCandidatePair|.
        </p>
      </li>
    </ol>
  </section>

  <section class="informative">
    <h2>Event summary</h2>
    <p>
      The following events fire on {{RTCIceController}} objects:</p>
    <table class="simple">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceController" data-dfn-type=event>candidatepairadded</dfn></th>
          <td>{{RTCIceCandidatePairEvent}}</td>
          <td>The [= ICE agent =] has gathered a candidate pair and is making it available to the script.</td>
        </tr>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceController" data-dfn-type=event>candidatepairupdated</dfn></th>
          <td>{{RTCIceCandidatePairUpdateEvent}}</td>
          <td>The [= ICE agent =] has updated the information it knows about a candidate pair (eg. the round trip time
            estimate).</td>
        </tr>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceController" data-dfn-type=event>candidatepairswitched</dfn></th>
          <td>{{RTCIceCandidatePairEvent}}</td>
          <td>The [= ICE agent =] has switched the transport to a different candidate pair.</td>
        </tr>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceController" data-dfn-type=event>candidatepairdestroyed</dfn></th>
          <td>{{RTCIceCandidatePairEvent}}</td>
          <td>The [= ICE agent =] has destroyed a candidate pair.</td>
        </tr>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceController" data-dfn-type=event>icepingproposed</dfn></th>
          <td>{{RTCIcePingProposalEvent}}</td>
          <td>The [= ICE agent =] has selected a candidate pair to ping for a connectivity check, but the ping has not
            yet been sent.
          </td>
        </tr>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceController" data-dfn-type=event>iceswitchproposed</dfn></th>
          <td>{{RTCIceSwitchProposalEvent}}</td>
          <td>The [= ICE agent =] has selected a candidate pair to switch the transport to, but the switch has not yet
            occurred.
          </td>
        </tr>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceController" data-dfn-type=event>icepruneproposed</dfn></th>
          <td>{{RTCIcePruneProposalEvent}}</td>
          <td>The [= ICE agent =] has selected one or more candidate pairs to prune, but the pruning has not yet
            occurred.
          </td>
        </tr>
      </tbody>
    </table>
  </section>

  <section class="appendix">
    <h2>Acknowledgements</h2>
    <p>
      The editors wish to thank the Working Group chairs for their support. The editors would like to thank Harald
      Alvestrand, Henrik Boström, Jonas Oreland, and Erik Övelius for their contributions to this
      specification.
    </p>
  </section>

</body>

</html>